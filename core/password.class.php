<?php
/*	Project:	EQdkp-Plus
 *	Package:	EQdkp-plus
 *	Link:		http://eqdkp-plus.eu
 *
 *	Copyright (C) 2006-2016 EQdkp-Plus Developer Team
 *
 *	This program is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU Affero General Public License as published
 *	by the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU Affero General Public License for more details.
 *
 *	You should have received a copy of the GNU Affero General Public License
 *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

if ( !defined('EQDKP_INC') ){
	header('HTTP/1.0 404 Not Found');exit;
}

class password extends gen_class {
	public static $shortcuts = array('puf'=>'urlfetcher');

	private $bcrypt_cost = 11;

	public $strBestHashMethod;


	public function __construct(){
		$this->strBestHashMethod = $this->getBestHashMethod();
	}


	/**
	 * Create a hash from a given password
	 *
	 * @param string $strPassword - the cleartext password
	 * @param string $strMethod - the hashing method. Default, the best method is choosen
	 * @return mixed - string for hash, false on error
	 */
	public function hash($strPassword, $strMethod = ''){
		if ($strMethod == '') $strMethod = $this->strBestHashMethod;

		switch ($strMethod){
			case "blowfish": return $this->hash_blowfish($strPassword);
				break;

			case "argon2id": return $this->hash_argon2id($strPassword);
				break;

			case "argon2i": return $this->hash_argon2i($strPassword);
				break;

		}

		return false;
	}

	/**
	 * Checks a given plaintext password against the saved hash.
	 * If a salt is needed, it should be appended to the password, seperated by colon (:)
	 *
	 * @param string $strPassword
	 * @param string $strStoredHash
	 * @return boolean
	 */
	public function checkPassword($strPassword, $strStoredHash){
		if(strpos($strStoredHash, ':') !== false){
			list($strStoredHash, $strSalt) = explode(':', $strStoredHash);
		} else {
			$strSalt = "";
		}

		$strHashedPassword = $this->prehash($strPassword, $strSalt);
		$strMethod = $this->getHashMethod($strStoredHash);
		$strHash = false;
		$status = 0;

		switch ($strMethod){
			case "ext_des":
			case "blowfish_old":
			case "blowfish": if(isset($strSalt) && strlen($strSalt)){
								//The old way, when we saved the salt
								$strHash = crypt($strHashedPassword, $strStoredHash);
							} else {
								//The new way with autogenerated salt
								return password_verify($strPassword, $strStoredHash);
							}
				break;
			case "argon2i":
			case "argon2id":	return password_verify($strPassword, $strStoredHash);
				break;

			case "sha512":	$strHash = $this->crypt_private($strHashedPassword, $strStoredHash);
				break;

			case "plain_md5": $strHash = md5($strPassword);
				break;

			case "salted_sha512": $strHash = hash('sha512', $strSalt.$strPassword);
		}

		if(!$strHash) return false;

		if (function_exists('hash_equals')) {
			return (hash_equals($strStoredHash, $strHash));
		}


		//Do the compare on our own
		if (strlen($strStoredHash) !== strlen($strHash)) {
			return false;
		}

		//Prevent Timing attacks
		for ($i = 0; $i < strlen($strHash); $i++) {
            $status |= (ord($strHash[$i]) ^ ord($strStoredHash[$i]));
        }

        $blnCompareStatus = ($status === 0);

		return ($blnCompareStatus);
	}

	/**
	 * Builds a sha512 hash over the password concatenated with the salt
	 *
	 * @param string $strPassword
	 * @param string $strSalt
	 * @return string
	 */
	private function prehash($strPassword, $strSalt=''){
		return hash('sha512', $strSalt.$strPassword);
	}

	/**
	 * Returns the best suitable hashing algorithm on the sytem
	 *
	 * @throws Exception
	 * @return string
	 */
	public function getBestHashMethod(){
		if (CRYPT_BLOWFISH == 1) return "blowfish";
		if(defined('PASSWORD_ARGON2ID')) return "argon2id";
		if(defined('PASSWORD_ARGON2I')) return "argon2i";

		throw new Exception("No suitable Crypto (bcrypt, argon) found.");
	}

	/**
	 * Returns hashing method of a given Hash
	 *
	 * @param string $strHash
	 * @return string|boolean
	 */
	private function getHashMethod($strHash){
		if(strpos($strHash, ':') !== false){
			list($strHash, $strSalt) = explode(':', $strHash);
		}
		if (substr($strHash, 0, 4) == '$2a$' && strlen($strHash) == 60) return "blowfish_old";
		if (substr($strHash, 0, 4) == '$2y$' && strlen($strHash) == 60) return "blowfish";
		if (substr($strHash, 0, 4) == '$2x$' && strlen($strHash) == 60) return "blowfish";
		if (substr($strHash, 0, 10) == '$argon2id$') return "argon2id";
		if (substr($strHash, 0, 9) == '$argon2i$') return "argon2i";
		if (substr($strHash, 0, 1) == '_' && strlen($strHash) == 20) return "ext_des";
		if (substr($strHash, 0, 3) == '$S$' && strlen($strHash) == 98) return "sha512";
		if (strlen($strHash) == 32) return "plain_md5";
		if (strlen($strHash) == 128) return "salted_sha512";

		return false;
	}


	/**
	 * Checks if a given Hash needs an update
	 *
	 * @param string $strHash
	 * @return boolean
	 */
	public function hashNeedsUpdate($strHash){
		if(strpos($strHash, ':') !== false){
			list($strHash, $strSalt) = explode(':', $strHash);
		}

		$strMethod = $this->getHashMethod($strHash);
		$strBestMethod = $this->strBestHashMethod;

		if ($strMethod && ($strMethod !== $strBestMethod)){
			return true;
		}

		switch($strMethod){
			case 'blowfish':
			case 'blowfish_old': return password_needs_rehash($strHash, PASSWORD_BCRYPT, array('cost' => $this->bcrypt_cost));
				break;

			case 'argon2id': return password_needs_rehash($strHash, PASSWORD_ARGON2ID);
				break;

			case 'argon2i': return password_needs_rehash($strHash, PASSWORD_ARGON2I);
				break;
		}


		return false;
	}

	/**
	 * Generate the Blowfish Hash with PHP built-in methods
	 *
	 * @param string $password
	 * @return string
	 */
	private function hash_blowfish($password){
		return password_hash($password, PASSWORD_BCRYPT, array('cost' => $this->bcrypt_cost));
	}

	/**
	 * Generate the Argon2ID Hash with PHP built-in methods
	 *
	 * @param string $password
	 * @return string
	 */
	private function hash_argon2id($password){
		return password_hash($password, PASSWORD_ARGON2ID);
	}

	/**
	 * Generate the Argon2I Hash with PHP built-in methods
	 *
	 * @param string $password
	 * @return string
	 */
	private function hash_argon2i($password){
		return password_hash($password, PASSWORD_ARGON2I);
	}
	
	
	public function checkIfLeaked($strPassword){
		$strSHA1hash = strtoupper(sha1($strPassword));
		
		$strFirstHashpart = substr($strSHA1hash, 0, 5);
		$strLastHashpart = substr($strSHA1hash, 5);
		
		$response = $this->puf->fetch('https://api.pwnedpasswords.com/range/'.$strFirstHashpart);
		if($response){
			$arrParts = array();
			
			if(strlen($response)){
				$arrParts = explode("\r\n", $response);
			}
			
			if(is_array($arrParts)){
				foreach($arrParts as $val){
					$arrSubParts = explode(':', $val);
					
					if($arrSubParts[0] === $strLastHashpart){
						return true;
					}
				}
			}
		}
		
		return false;

	}
}
